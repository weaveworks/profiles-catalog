apiVersion: magalix.com/v1
kind: Policy
metadata:
  name: weave.policies.container-running-as-root
spec:
  id: weave.policies.container-running-as-root
  name: Container Running As Root
  description: "Running as root gives the container full access to all resources in the VM it is running on. Containers should not run with such access rights unless required by design. This Policy enforces that the `securityContext.runAsNonRoot` attribute is set to `true`. \n"
  how_to_solve: "You should set `securityContext.runAsNonRoot` to `true`. Not setting it will default to giving the container root user rights on the VM that it is running on. \n```\n...\n  spec:\n    securityContext:\n      runAsNonRoot: true\n```\nhttps://kubernetes.io/docs/tasks/configure-pod-container/security-context/\n"
  category: weave.categories.pod-security
  severity: high
  targets: {kind: [Deployment, Job, ReplicationController, ReplicaSet, DaemonSet, StatefulSet, CronJob]}
  controls:
    - weave.controls.pci-dss.2.2.4
    - weave.controls.pci-dss.2.2.5
    - weave.controls.cis-benchmark.5.2.6
    - weave.controls.mitre-attack.4.1
    - weave.controls.nist-800-190.3.3.1
    - weave.controls.gdpr.24
    - weave.controls.gdpr.25
    - weave.controls.gdpr.32
  tags: [pci-dss, cis-benchmark, mitre-attack, nist800-190, gdpr, default]
  parameters:
    - name: exclude_namespace
      type: string
      required: false
      default: kube-system
    - name: exclude_label_key
      type: string
      required: false
      default:
    - name: exclude_label_value
      type: string
      required: false
      default:
  code: |-
    package weave.advisor.podSecurity.runningAsRoot

    exclude_namespace := input.parameters.exclude_namespace
    exclude_label_key := input.parameters.exclude_label_key
    exclude_label_value := input.parameters.exclude_label_value

    # Check for missing securityContext.runAsNonRoot (missing in both, pod and container)
    violation[result] {
    	not exclude_namespace == controller_input.metadata.namespace
    	not exclude_label_value == controller_input.metadata.labels[exclude_label_key]

    	controller_spec.securityContext
    	not controller_spec.securityContext.runAsNonRoot
    	not controller_spec.securityContext.runAsNonRoot == false

    	some i
    	containers := controller_spec.containers[i]
    	containers.securityContext
    	not containers.securityContext.runAsNonRoot
    	not containers.securityContext.runAsNonRoot == false

    	result = {
    		"issue detected": true,
    		"msg": sprintf("Container missing spec.template.spec.containers[%v].securityContext.runAsNonRoot while Pod spec.template.spec.securityContext.runAsNonRoot is not defined as well.", [i]),
    		"violating_key": sprintf("spec.template.spec.containers[%v].securityContext", [i]),
    	}
    }

    # Container security context
    # Check if containers.securityContext.runAsNonRoot exists and = false
    violation[result] {
    	not exclude_namespace == controller_input.metadata.namespace
    	not exclude_label_value == controller_input.metadata.labels[exclude_label_key]

    	some i
    	containers := controller_spec.containers[i]
    	containers.securityContext
    	containers.securityContext.runAsNonRoot == false

    	result = {
    		"issue detected": true,
    		"msg": sprintf("Container spec.template.spec.containers[%v].securityContext.runAsNonRoot should be set to true ", [i]),
    		"violating_key": sprintf("spec.template.spec.containers[%v].securityContext.runAsNonRoot", [i]),
    		"recommended_value": true,
    	}
    }

    # Pod security context
    # Check if spec.securityContext.runAsNonRoot exists and = false
    violation[result] {
    	not exclude_namespace == controller_input.metadata.namespace
    	not exclude_label_value == controller_input.metadata.labels[exclude_label_key]

    	controller_spec.securityContext
    	controller_spec.securityContext.runAsNonRoot == false

    	result = {
    		"issue detected": true,
    		"msg": "Pod spec.template.spec.securityContext.runAsNonRoot should be set to true",
    		"violating_key": "spec.template.spec.securityContext.runAsNonRoot",
    		"recommended_value": true,
    	}
    }

    controller_input = input.review.object

    controller_spec = controller_input.spec.template.spec {
    	contains(controller_input.kind, {"StatefulSet", "DaemonSet", "Deployment", "Job", "ReplicaSet"})
    } else = controller_input.spec {
    	controller_input.kind == "Pod"
    } else = controller_input.spec.jobTemplate.spec.template.spec {
    	controller_input.kind == "CronJob"
    }

    contains(kind, kinds) {
    	kinds[_] = kind
    }
---
apiVersion: magalix.com/v1
kind: Policy
metadata:
  name: weave.policies.containers-running-with-privilege-escalation
spec:
  id: weave.policies.containers-running-with-privilege-escalation
  name: Containers Running With Privilege Escalation
  description: |
    Containers are running with PrivilegeEscalation configured. Setting this Policy to `true` allows child processes to gain more privileges than its parent process.  

    This Policy gates whether or not a user is allowed to set the security context of a container to `allowPrivilegeEscalation` to `true`. The default value for this is `false` so no child process of a container can gain more privileges than its parent.

    There are 2 parameters for this Policy:
    - exclude_namespace (string) : This sets a namespace you want to exclude from Policy compliance checking. 
    - allow_privilege_escalation (bool) : This checks for the value of `allowPrivilegeEscalation` in your spec.  
  how_to_solve: |
    Check the following path to see what the PrivilegeEscalation value is set to.
    ```
    ...
      spec:
        containers:
          securityContext:
            allowPrivilegeEscalation: <value>
    ```
    https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
  category: weave.categories.pod-security
  severity: high
  targets: {kind: [Deployment, Job, ReplicationController, ReplicaSet, DaemonSet,
      StatefulSet, CronJob]}
  controls:
  - weave.controls.pci-dss.2.2.4
  - weave.controls.pci-dss.2.2.5
  - weave.controls.cis-benchmark.5.2.5
  - weave.controls.mitre-attack.4.1
  - weave.controls.nist-800-190.3.3.2
  - weave.controls.gdpr.25
  - weave.controls.gdpr.32
  - weave.controls.gdpr.24
  - weave.controls.soc2-type-i.1.6.1
  tags: [pci-dss, cis-benchmark, mitre-attack, nist800-190, gdpr, default, soc2-type1]
  parameters:
  - name: exclude_namespace
    type: string
    required: true
    default: kube-system
  - name: allow_privilege_escalation
    type: boolean
    required: true
    default: false
  - name: exclude_label_key
    type: string
    required: false
    default:
  - name: exclude_label_value
    type: string
    required: false
    default:
  code: |
    package weave.advisor.podSecurity.privilegeEscalation

    exclude_namespace := input.parameters.exclude_namespace
    allow_privilege_escalation := input.parameters.allow_privilege_escalation
    exclude_label_key := input.parameters.exclude_label_key
    exclude_label_value := input.parameters.exclude_label_value

    violation[result] {
      some i
      isExcludedNamespace == false
      not exclude_namespace == controller_input.metadata.namespace
      not exclude_label_value == controller_input.metadata.labels[exclude_label_key]
      containers := controller_spec.containers[i]
      allow_priv := containers.securityContext.allowPrivilegeEscalation
      not allow_priv == allow_privilege_escalation
      result = {
        "issue detected": true,
        "msg": sprintf("Container's privilegeEscalation should be set to '%v'; detected '%v'", [allow_privilege_escalation, allow_priv]),
        "violating_key": sprintf("spec.template.spec.containers[%v].securityContext.allowPrivilegeEscalation", [i]),
        "recommended_value": allow_privilege_escalation
      }
    }

    isExcludedNamespace  = true {
      input.review.object.metadata.namespace == exclude_namespace
    }else = false {true}

    is_array_contains(array,str) {
      array[_] = str
    }

    # Controller input
    controller_input = input.review.object

    # controller_container acts as an iterator to get containers from the template
    controller_spec = controller_input.spec.template.spec {
      contains_kind(controller_input.kind, {"StatefulSet" , "DaemonSet", "Deployment", "Job"})
    } else = controller_input.spec {
      controller_input.kind == "Pod"
    } else = controller_input.spec.jobTemplate.spec.template.spec {
      controller_input.kind == "CronJob"
    }

    contains_kind(kind, kinds) {
      kinds[_] = kind
    }
---
apiVersion: magalix.com/v1
kind: Policy
metadata:
  name: weave.policies.containers-read-only-root-filesystem
spec:
  id: weave.policies.containers-read-only-root-filesystem
  name: Containers Read Only Root Filesystem
  description: |
    This Policy will cause a violation if the root file system is not mounted as specified. As a security practice, the root file system should be read-only or expose risk to your nodes if compromised. 

    This Policy requires containers must run with a read-only root filesystem (i.e. no writable layer).
  how_to_solve: |
    Set `readOnlyRootFilesystem` in your `securityContext` to the value specified in the Policy. 
    ```
    ...
      spec:
        containers:
          - securityContext:
              readOnlyRootFilesystem: <read_only>
    ```

    https://kubernetes.io/docs/concepts/policy/pod-security-policy/#volumes-and-file-systems
  category: weave.categories.pod-security
  severity: high
  targets: {kind: [Deployment, Job, ReplicationController, ReplicaSet, DaemonSet,
      StatefulSet, CronJob]}
  controls:
  - weave.controls.mitre-attack.3.2
  - weave.controls.nist-800-190.4.4.4
  tags: [mitre-attack, nist800-190]
  parameters:
  - name: read_only
    type: boolean
    required: true
    default: true
  - name: exclude_namespace
    type: string
    required: false
    default:
  - name: exclude_label_key
    type: string
    required: false
    default:
  - name: exclude_label_value
    type: string
    required: false
    default:
  code: |
    package weave.advisor.podSecurity.enforce_ro_fs

    read_only = input.parameters.read_only
    exclude_namespace := input.parameters.exclude_namespace
    exclude_label_key := input.parameters.exclude_label_key
    exclude_label_value := input.parameters.exclude_label_value

    violation[result] {
      not exclude_namespace == controller_input.metadata.namespace
      not exclude_label_value == controller_input.metadata.labels[exclude_label_key]
      some i
      containers := controller_spec.containers[i]
      root_fs := containers.securityContext.readOnlyRootFilesystem
      not root_fs == read_only
      result = {
        "issue detected": true,
        "msg": sprintf("readOnlyRootFilesystem should equal '%v'; detected '%v'", [read_only, root_fs]),
        "recommended_value": read_only,
        "violating_key": sprintf("spec.template.spec.containers[%v].securityContext.readOnlyRootFilesystem", [i]) 
      }
    }

    # Controller input
    controller_input = input.review.object

    # controller_container acts as an iterator to get containers from the template
    controller_spec = controller_input.spec.template.spec {
      contains_kind(controller_input.kind, {"StatefulSet" , "DaemonSet", "Deployment", "Job"})
    } else = controller_input.spec {
      controller_input.kind == "Pod"
    } else = controller_input.spec.jobTemplate.spec.template.spec {
      controller_input.kind == "CronJob"
    }

    contains_kind(kind, kinds) {
      kinds[_] = kind
    }
